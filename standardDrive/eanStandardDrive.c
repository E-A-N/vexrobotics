#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  leftShaftEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rightShaftEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  leftSonar,      sensorSONAR_inch)
#pragma config(Sensor, dgtl7,  rightSonar,     sensorSONAR_inch)
#pragma config(Motor,  port1,           leftMotor,     tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port4,           xPort,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           clawMotor,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           armMotor,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          rightMotor,    tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Declare Constants and Variables
const int DFORWARD    =  1;
const int DBACKWARD   = -1;
const int TRIGHT      =  1;
const int TLEFT       = -1;
const int RIGHT_ANGLE = 900;
const int U_TURN      = 1800;


//nAvgBatteryLevel; //calculate battery power
//nImmediateBatteryLevel;


//Define Behavioral Functions
void driveForward(int direction = 1)
{
    motor[leftMotor]  =  -127 * direction;
    motor[rightMotor] =  -127 * direction;
}

void autoForward(int direction)
{
		SensorValue[rightShaftEncoder] = 0;
		SensorValue[leftShaftEncoder] = 0;
		while (abs(SensorValue[rightShaftEncoder]) < 1350)
  	{
  			driveForward(direction);
  	}
  	wait1Msec(500);
}

void autoTimeForward(int time)
{
	motor[leftMotor]  =  127;
    motor[rightMotor] = -127;
  	wait1Msec(time);
  	motor[leftMotor]  =  0;
    motor[rightMotor] = 	0;
}

//Define Math Conventions

//The Sign Function Transforms any positive number to 1 or any negative number to -1
int sign(int num)
{
    if (num > 0)
    {
    	return 1;
  	}
  	else if (num < 0)
  	{
  		return -1;
	}
	else
	{
		return 0;
	}
}

void quickTurn(int angle, int speed)
{
	SensorValue[gyro] = 0;
    switch(angle)
    {
		case RIGHT_ANGLE:
		case U_TURN:
    		//abs make any number positive ie abs(-1000 = 100
    		while( abs(SensorValue[gyro]) < angle )
        	{
    		      motor[rightMotor] =    speed;
    		      motor[leftMotor]  =   	-speed;
        	}
        	break;

		//Reverse Angles
		case -RIGHT_ANGLE:
		case -U_TURN:
    		while (abs(SensorValue[gyro]) < abs(angle))
    		{
    				motor[rightMotor] =    -speed;
    				motor[leftMotor] =   	  speed;
    		}
    		break;
    }
    //stop the motors and cool down
    angle = angle > 0 ? 1 : -1;
   /* switch(angle)
    {
		    case (-1):
		    motor[rightMotor] =     5;
				motor[leftMotor]  =    -5;
				break;

				case (1):
				motor[rightMotor] =   -5;
				motor[leftMotor]  =    5;
				break;
		}*/
		wait1Msec(250);
}
task main()
{
        //Calibrate the gyro sensor
        SensorType[gyro] = sensorNone;
        wait1Msec(1000);
        SensorType[gyro] = sensorGyro;
        wait1Msec(2000);
	  SensorValue[rightShaftEncoder] = 0;
	  SensorValue[leftShaftEncoder] = 0;

		while(true)
		{
			/*
				if (vexRT[Btn8L])
		    {
		        autoTimeForward(50);
		  	}
		    if (vexRT[Btn8U])
		    {
		        autoTimeForward(100);+-
		  	}
		  	if (vexRT[Btn8R])
		    {
		        autoTimeForward(150);
		  	}
		  	if (VexRT[Btn6D])
		  	{
		  			motor[leftMotor]  =  -127;
      			motor[rightMotor] =   127;
      			wait1Msec(10);
		  	}
		  */
			  /*
			  motor[rightMotor} =   (SensorValue[rightShaftEncoder] -2000)/3.5;
			  motor[leftMotor}  =  -(SensorValue[rightShaftEncoder] -2000 )/3.5;
			  */
			  /* This code works, save for later
			     This code makes robot go for 6feet and then stop
			  if (SensorValue (rightShaftEncoder) > -1990)
				{
						motor[rightMotor} =  -127;
						motor[leftMotor}  =   107;
				}
				else
				{
						motor[rightMotor] = 0;
						motor[leftMotor] = 0;
				}
				*/
				if (VexRT[Btn7U]) //90 Degree turn right
			  {
				    driveForward();
		    }
		    else if (VexRT[Btn7D]) //90 Degree turn right
			  {
				    driveForward(-1);
		    }
				else if (VexRT[Btn6U]) //90 Degree turn right
			  {
				    quickTurn(-RIGHT_ANGLE,50);
		    }
		    else if (VexRT[Btn5U]) //90 Degree turn right
			  {
				    quickTurn(RIGHT_ANGLE,127);
		    }
		    else if (VexRT[Btn8U])
		  	{
		  			autoForward(1);
				}
				else if (VexRT[Btn8D])
		  	{
		  			autoForward(-1);
				}
		    else
		  	{
						motor[rightMotor] =   -VexRT[Ch3];
						motor[leftMotor] =   	-VexRT[Ch2];
				}
		}
}
